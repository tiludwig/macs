/*
 *	Torquer control for MACS
 *
 *	Torquers will be controlled by PWM-signals. These signals are generated by 
 *	the hardware timers with a resolution of 8-bit for half the input range, 
 *	9-bit for full input range. This is because negative dipole moments will
 *	cause a channel switch, so [-200, 0] -> 8-bit on channel B and [0, 200] ->
 *	8-bit on channel A.
 *
 * Copyright 2018 Tim Ludwig
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy 
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights 
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all 
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ 


#ifndef TORQUER_H_
#define TORQUER_H_

#include <avr/io.h>

#define TORQUER_SLEEP_DDR			(DDRC)
#define TORQUER_SLEEP_PORT			(PORTC)
#define TORQUER_SLEEP_PIN			(1 << PC0)
#define TORQUER_ENABLE_SLEEP()		(TORQUER_SLEEP_PORT &= ~TORQUER_SLEEP_PIN)
#define TORQUER_DISABLE_SLEEP()		(TORQUER_SLEEP_PORT |= TORQUER_SLEEP_PIN)

#define TIM0_CHANNEL_PORT			(PORTD)
#define TIM0_CHANNEL_A_PIN			(1 << PD6)
#define TIM0_CHANNEL_B_PIN			(1 << PD5)
#define TIM0_TCCR0A_BASE_CFG		((1 << WGM01) | (1 << WGM00))
#define TIM0_TCCR0A_CHANNEL_A		((1 << COM0A1) | TIM0_TCCR0A_BASE_CFG)
#define TIM0_TCCR0A_CHANNEL_B		((1 << COM0B1) | TIM0_TCCR0A_BASE_CFG)
#define TIM0_TCCR0B_DISABLE			(0)
#define TIM0_TCCR0B_ENABLE			((1 << CS01))

#define TIM1_CHANNEL_A_PIN			(1 << PB1)
#define TIM1_CHANNEL_B_PIN			(1 << PB2)
#define TIM1_CHANNEL_PORT			(PORTB)
#define TIM1_TCCR1A_BASE_CFG		(1 << WGM10)
#define TIM1_TCCR1B_BASE_CFG		(1 << WGM12)
#define TIM1_TCCR1A_CHANNEL_A		((1 << COM1A1) | TIM1_TCCR1A_BASE_CFG)
#define TIM1_TCCR1A_CHANNEL_B		((1 << COM1B1) | TIM1_TCCR1A_BASE_CFG)
#define TIM1_TCCR1B_DISABLE			(0)
#define TIM1_TCCR1B_ENABLE			(TIM1_TCCR1B_BASE_CFG | (1 << CS11))

#define TIM2_CHANNEL_A_PORT			(PORTB)
#define TIM2_CHANNEL_B_PORT			(PORTD)
#define TIM2_CHANNEL_A_PIN			(1 << PB3)
#define TIM2_CHANNEL_B_PIN			(1 << PD3)
#define TIM2_TCCR2A_BASE_CFG		((1 << WGM21) | (1 << WGM20))
#define TIM2_TCCR2A_CHANNEL_A		((1 << COM2A1) | TIM2_TCCR2A_BASE_CFG)
#define TIM2_TCCR2A_CHANNEL_B		((1 << COM2B1) | TIM2_TCCR2A_BASE_CFG)
#define TIM2_TCCR2B_DISABLE			(0)
#define TIM2_TCCR2B_ENABLE			((1 << CS21))




uint16_t getTimestamp();

void xTorquerInitialize();
void yTorquerInitialize();
void zTorquerInitialize();

void xTorquerDisable();
void yTorquerDisable();
void zTorquerDisable();

void torquerEnable();
void torquerDisableAll();

void xTorquerEnableChannelA();
void xTorquerEnableChannelB();

void yTorquerEnableChannelA();
void yTorquerEnableChannelB();

void zTorquerEnableChannelA();
void zTorquerEnableChannelB();

void xTorquerSetDutyCycle(uint8_t dutyCycle);
void yTorquerSetDutyCycle(uint8_t dutyCycle);
void zTorquerSetDutyCycle(uint8_t dutyCycle);


#endif /* TORQUER_H_ */