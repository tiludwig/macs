/*
 *	Torquer control for MACS
 *
 *	Torquers will be controlled by PWM-signals. These signals are generated by 
 *	the hardware timers with a resolution of 8-bit for half the input range, 
 *	9-bit for full input range. This is because negative dipole moments will
 *	cause a channel switch, so [-200, 0] -> 8-bit on channel B and [0, 200] ->
 *	8-bit on channel A.
 *
 * Copyright 2018 Tim Ludwig
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy 
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights 
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all 
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ 


#ifndef TORQUER_H_
#define TORQUER_H_

#include <avr/io.h>

#define TORQUER_SLEEP_DDR			(DDRC)
#define TORQUER_SLEEP_PORT			(PORTC)
#define TORQUER_SLEEP_PIN			(1 << PC0)
#define TORQUER_ENABLE_SLEEP()		(TORQUER_SLEEP_PORT &= ~TORQUER_SLEEP_PIN)
#define TORQUER_DISABLE_SLEEP()		(TORQUER_SLEEP_PORT |= TORQUER_SLEEP_PIN)

#define TIM0_CHANNEL_PORT			(PORTD)
#define TIM0_CHANNEL_A_PIN			(1 << PD6)
#define TIM0_CHANNEL_B_PIN			(1 << PD5)
#define TIM0_TCCR0A_BASE_CFG		((1 << WGM01) | (1 << WGM00))
#define TIM0_TCCR0A_CHANNEL_A		((1 << COM0A1) | TIM0_TCCR0A_BASE_CFG)
#define TIM0_TCCR0A_CHANNEL_B		((1 << COM0B1) | TIM0_TCCR0A_BASE_CFG)
#define TIM0_TCCR0B_DISABLE			(0)
#define TIM0_TCCR0B_ENABLE			((1 << CS01))

#define TIM1_CHANNEL_A_PIN			(1 << PB1)
#define TIM1_CHANNEL_B_PIN			(1 << PB2)
#define TIM1_CHANNEL_PORT			(PORTB)
#define TIM1_TCCR1A_BASE_CFG		(1 << WGM10)
#define TIM1_TCCR1B_BASE_CFG		(1 << WGM12)
#define TIM1_TCCR1A_CHANNEL_A		((1 << COM1A1) | TIM1_TCCR1A_BASE_CFG)
#define TIM1_TCCR1A_CHANNEL_B		((1 << COM1B1) | TIM1_TCCR1A_BASE_CFG)
#define TIM1_TCCR1B_DISABLE			(0)
#define TIM1_TCCR1B_ENABLE			(TIM1_TCCR1B_BASE_CFG | (1 << CS11))

#define TIM2_CHANNEL_A_PORT			(PORTB)
#define TIM2_CHANNEL_B_PORT			(PORTD)
#define TIM2_CHANNEL_A_PIN			(1 << PB3)
#define TIM2_CHANNEL_B_PIN			(1 << PD3)
#define TIM2_TCCR2A_BASE_CFG		((1 << WGM21) | (1 << WGM20))
#define TIM2_TCCR2A_CHANNEL_A		((1 << COM2A1) | TIM2_TCCR2A_BASE_CFG)
#define TIM2_TCCR2A_CHANNEL_B		((1 << COM2B1) | TIM2_TCCR2A_BASE_CFG)
#define TIM2_TCCR2B_DISABLE			(0)
#define TIM2_TCCR2B_ENABLE			((1 << CS21))



/*
 *	Gets the current system time
 *
 *	Time is measurement using timer 0. Because this timer also runs the z torquer,
 *	the system time is measured in 256us ticks. Use this function to compute time
 *	differences between two timestamps. 
 */
uint16_t getTimestamp();

/*
 *	Initializes the x torquer
 *
 *	After initialization the torquer is off.
 */
void xTorquerInitialize();

/*
 *	Initializes the y torquer
 *
 *	After initialization the torquer is off.
 */
void yTorquerInitialize();

/*
 *	Initializes the z torquer
 *
 *	After initialization the torquer is off.
 */
void zTorquerInitialize();


/*
 *	Disables the x torquer
 */
void xTorquerDisable();

/*
 *	Disables the y torquer
 */
void yTorquerDisable();

/*
 *	Disables the z torquer
 */
void zTorquerDisable();

/*
 *	Disables sleep mode for all three torquers
 */
void torquerDisableSleep();

/*
 *	Disables all torquers and enters sleep mode
 */
void torquerDisableAll();


/*
 *	Enable the output channel A for the x torqer
 */
void xTorquerEnableChannelA();

/*
 *	Enable the output channel B for the x torqer
 */
void xTorquerEnableChannelB();


/*
 *	Enable the output channel A for the y torqer
 */
void yTorquerEnableChannelA();

/*
 *	Enable the output channel B for the y torqer
 */
void yTorquerEnableChannelB();


/*
 *	Enable the output channel A for the z torqer
 */
void zTorquerEnableChannelA();

/*
 *	Enable the output channel B for the z torqer
 */
void zTorquerEnableChannelB();


/*
 *	Sets the duty cycle for the x torquer
 *
 *	This will set the duty cycle off both channels. Since only one channel can be active 
 *	by design, this doesn't pose a problem. However, if the user is to manipulate the 
 *	timer registers outside of this module, this has to be kept in mind.
 */
void xTorquerSetDutyCycle(uint8_t dutyCycle);

/*
 *	Sets the duty cycle for the y torquer
 *
 *	This will set the duty cycle off both channels. Since only one channel can be active 
 *	by design, this doesn't pose a problem. However, if the user is to manipulate the 
 *	timer registers outside of this module, this has to be kept in mind.
 */
void yTorquerSetDutyCycle(uint8_t dutyCycle);

/*
 *	Sets the duty cycle for the z torquer
 *
 *	This will set the duty cycle off both channels. Since only one channel can be active 
 *	by design, this doesn't pose a problem. However, if the user is to manipulate the 
 *	timer registers outside of this module, this has to be kept in mind.
 */
void zTorquerSetDutyCycle(uint8_t dutyCycle);


#endif /* TORQUER_H_ */